---
output:
  pdf_document: 
    keep_tex: yes
  html_document: default
---

## Pacote R com as funções de treinamento, execução e visualização de dados

##### importações

```{r imports}
library(bnlearn)
library(Hmisc)
library(dplyr)
library(caTools)
library(ggplot2)
source('bnlearn_discrete_multivar_prediction_eval.R')
set.seed(101) 
library(dbnR)
library(data.table)
library(caret)
#library(rbmn)
```

```{r BuildSimulationData}
BuildSimulationData <- function (nHarvests, nPhases, nAreas = NULL, ...) {
  
  
  areasList <- list()
  if(is.null(nAreas)){
# por padrão gera-se 6 áreas
# cada área tem uma relação entre as variáveis e a produção 
    
    areanames = c("Area_1", "Area_2", "Area_3", "Area_4", "Area_5", "Area_6")
    areatype  = c(1,2,3,4,5,6)
    for (i in 1 : length(areanames)){
      areasList[[i]] <- c(areanames =  areanames[i], areatype  = areatype[i])
    }
  }else{
# se for definido o número de áreas, os tipos são atribuidos aleatóriamente
    for (i in 1 : nAreas){
      tempType = sample(1:6, 1)
      #tempType = 5
      tempName <- paste("Area", i, sep = "_")
      areasList[[i]] = c(areaName = tempName, areatype = tempType)
    }
  }
  
# definição das variáveis pela funcao defVars 
  defProdVariables = defVars(...)
 
  completeSimValues = list()
  namesArea = array(dim = length(areasList))
  
# Para cada área Calcula os valores das variáveis
# e da producao pela função setSimVarValues
  
  for (a in 1:length(areasList)) {
    
    #cat("Calculando valores da área ",a,"\n")

    completeSimValues[[a]] = setSimVarValues(nHarvests, areasList[[a]][2],defProdVariables,nPhases)
    namesArea[a] = paste("Area", a, "type", areasList[[a]][2], sep = "_")
  }
  names(completeSimValues) = namesArea
  
  return (completeSimValues)
}
```

```{r defVars}
# função para geração das variáveis
# chamada no escopo da função BuildSimulationData

defVars <- function (n_var = NULL, type_var = NULL, name_var = NULL){
  prodVariables = list()

  # Se não for definido o número de variáveis o padrão são as 3 abaixo  
  if(is.null(n_var)){
# Definição das variáveis: nome, valor mínimo, valor máximo, tipo 
    # type (up=1,osc=2,const=3)
    prodVariables[[1]] = c("PrecAcum",0,1,1)
    prodVariables[[2]] = c("Insol",0,1,2)
    prodVariables[[3]] = c("Compact",-1,1,3)

  return (prodVariables)
  }else
    if(!is.null(type_var) | !is.null(name_var)){
# sendo informado o n de variáveis e o nome e o comportamento delas
# as variáveis são geradas conforme abaixo:
      if(length(type_var)!= n_var | length(name_var)!= n_var){
        stop("parâmetros incorretos. Se informados, tipos e nomes de variáveis devem ser informados para todas as variáveis")
      }else{
        for (i in 1 : n_var){
        # type (up=1,osc=2,const=3)
          if(type_var[i] == 3){
            prodVariables[[i]] = c(name_var[i], -1, 1, type_var[i])
          }else{
            prodVariables[[i]] = c(name_var[i], 0, 1, type_var[i])
          }
        }
      }
        return (prodVariables)
        }else{
# Sendo informado o n de variáveis, sem mais detalhes a geração 
# ocorre de maneira aleatória, conforme abaixo:
          for (i in 1 : n_var){
            tempType = sample(1:3, 1)
            tempName <- paste("x", i, sep = "_" )
            if(tempType == 3){
              prodVariables[[i]] = c(tempName, -1, 1, tempType)
              }else{
                prodVariables[[i]] = c(tempName, 0, 1, tempType)
              }
            }
          return (prodVariables)
        }
}

```

```{r setSimVarValues}
# Função para geração dos valores das variáveis e das colheitas para cada
# área informada.
#CHAMADA NO ESCOPO DA FUNÇÃO BuildSimulationData()
#A função é chamada uma vez por área

setSimVarValues <- function (harvests, areatype, prodvars, nPhases){
  colheitas <-list()
  names_colheitas <- array(dim = harvests)
  
  # define os nomes das variáveis 
  for(i in 1: harvests){
# pra cada colheita da área
  # cria uma matriz de 'numero de fases' linhas e
  # 'numero de variáveis' colunas 
  # (sendo a v pridução nvariaveis independente +1)
  # aqui eu usei matrizes pq é mais fácil fazer operações matemáticas 
  # nas matrizes
    fases <- matrix(nrow=nPhases, ncol= length(prodvars)+1)
    colnames(fases) <-  colnames(fases, do.NULL = FALSE, prefix = "X_")
    colnames(fases)[length(prodvars)+1] <-  "colheita"
    rownames(fases) <-  rownames(fases, do.NULL = FALSE, prefix = "fase_")
    colheitas[[i]] = fases
    names_colheitas[i] = paste("colheita", i, sep = "_")
  }
  names(colheitas) = names_colheitas
  
# gera os valores das variáveis independentes
  for (var in 1 : length(prodvars)){# pra cada vaiável 
    for (harv in 1:harvests) {# pra cada colheita
      random_value   = runif(1, 
                             min=as.numeric(prodvars[[var]][2]),
                             max=as.numeric(prodvars[[var]][3]))
      last_value_var = 0
      const_value    = random_value
      for (pha in 1:nPhases){ #pra cada fase
        # type (up=1,osc=2,const=3)
        if (prodvars[[var]][4]==1){
          v_value = random_value + last_value_var
          last_value_var = v_value
        }else
          if (prodvars[[var]][4]==2){
            v_value = random_value
          }else
            if (prodvars[[var]][4]==3){
# ADICIONANDO RUIDO À VARIÁVEL X3 PARA NÃO INTERFERIR NO APRENDIZADO DA REDE
              v_value = const_value + rnorm(1, 0, .15)
            }
        
        colheitas[[harv]][pha,var] = v_value
        random_value = runif(1,
                             min=as.numeric(prodvars[[var]][2]), 
                             max=as.numeric(prodvars[[var]][3]))
      }#for pha in 1:nPhases
    }#for harv in 1:harvests
  }#for var in 1 : length(prodvars)

# Normalizando (entre 0 e 1 ou 1- e 1, conforme o tipo de variável) 
# dos dados das variáves antes de calcular os valores de produção  
  # DUVIDA: é a abordagem mais correta. (??)
  
for(h in 1 : harvests){
  for(v in 1 : length(prodvars)){
    if(max(abs(colheitas[[h]][,v])) > 1){
      colheitas[[h]][,v] = f_minmax(colheitas[[h]][,v])
      
# corrige valores extremos 0 e 1, adicionando/subtraindo
# um valor aleatório na 3ª casa depois da vírgula
      colheitas[[h]][which.max(colheitas[[h]][,v]),v] = max(colheitas[[h]][,v]) - runif(1)/100
      colheitas[[h]][which.min(colheitas[[h]][,v]),v] = min(colheitas[[h]][,v]) + runif(1)/100
 
     }
  }
}

# calcula o valor da produção com base nas relações arbitradas com as variáveis 
  
       
##### POR DEFAULT CONSIDERA-SE 3 VARIÁVES:
if(length(prodvars)==3){
#  print('AQUI')
 
# Área 1: o peso de produção varia linearmente com os valores de todas as variáveis 
# nas duas primeiras fases fenológicas
# Prod = (X11 + X12 + X21 + X22 + X31 + X32)
  if (areatype == 1) {
    
    for (h in 1: harvests){
# cada colheita recebe o somatório de cada linha (fase) 
# length(prodvars) é a quantidade de variáveis independentes
# lembrando que 'colheitas' é uma lista de matrizes, daí
# colheitas[[h]][,1:length(prodvars)] é:
  # colheitas[[h]] a matriz da colheita h
  # [,1:length(prodvars)] pra todas as linas da coluna 1 até a penultima
  # a última -- [,length(prodvars)+1] -- é onde fica a var 'colheita'
      colheitas[[h]][,length(prodvars)+1] = 
        sum(colheitas[[h]][,1:length(prodvars)])
    }
  }
   
# Área 2: o peso de produção varia com o quadrado de X1
# Prod = (X11^2 + X12^2 + X13^2 + X14^2 + X15^2)
  else if (areatype == 2) { 
    for(h in 1:harvests) {
        colheitas[[h]][,length(prodvars)+1] = sum((colheitas[[h]][,1])^2)
    }
  }
  
# Área 3: o peso de produção varia com o quadrado de X3
  else if (areatype == 3) {
     for(h in 1:harvests) {
        colheitas[[h]][,length(prodvars)+1] = sum((colheitas[[h]][,3])^2)
    }
  }
  
# Área 4: o peso de produção é inversamente proporcional à soma de X1 com X3
# Prod = 1/(X11+X13) + 1/(...)
  else if (areatype == 4) {
    for(h in 1:harvests) {
       producaoPhase = 0
      for(p in 1:nPhases){
        temp = 1/(colheitas[[h]][p,1]+colheitas[[h]][p,3])
         producaoPhase =  producaoPhase + temp
        }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
  
# Área 5: o peso da produção decresce com uma ponderação dos valores de X2:
# Prod = 1* X21 + 0,8* X22 + 0,6*X23 + 0,4*X24 + 0,2*X25
  else if (areatype == 5) {
    for(h in 1:harvests) {
       producaoPhase = 0
      chunk = 100/nPhases
      for(p in 1:nPhases){
        temp = (colheitas[[h]][p,2])*(100-(chunk*p-1))/100
         producaoPhase =  producaoPhase + temp
      }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
  
# Área 6: o peso da produção cresce com uma ponderação dos valores de X1:
# Prod = 0,2*X11 + 0,4* X12 + 0,6*X13 + 0,8*X14 + 1*X15
  else if (areatype == 6){
    for(h in 1:harvests) {
      producaoPhase = 0
      chunk = 100/nPhases
      for(p in 1:nPhases){
        temp = ((colheitas[[h]][p,1])*(chunk*p))/100
        producaoPhase =  producaoPhase + temp
        }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
}else{# se forem definidas mais de 3 variáveis 

#  print('ALI')
  
# Área 1: o peso de produção varia linearmente com os valores
# de todas as variáveis nas duas primeiras fases fenológicas
# Prod = (X11 + X12 + X21 + X22 + X31 + X32)

  if (areatype == 1) {
    for (h in 1: harvests){
      colheitas[[h]][,length(prodvars)+1] = sum(colheitas[[h]][,1:length(prodvars)])
    }
  }
  
# Área 2: o peso de produção varia com o quadrado das variáveis impares 
# Prod = Σ(Xi1^2 + Xi2^2 + Xi3^2 + Xi4^2 + Xi5^2) | i=(2k+1), k(0:infinito)
  else if (areatype == 2) { 
    for(h in 1:harvests) {
        producaoVar = 0
        for (v in 1 : length(prodvars)){
          if(v %% 2 == 0){next}
          temp = sum((colheitas[[h]][,v])^2)
          producaoVar =  producaoVar + temp
        }
        colheitas[[h]][,length(prodvars)+1] = producaoVar
    }
  }
  
# Área 3: o peso de produção varia com o quadrado das variáveis pares
# Prod = Σ(Xi1^2 + Xi2^2 + Xi3^2 + Xi4^2 + Xi5^2) | i=(2k), k(0:infinito)
  else if (areatype == 3){
    for(h in 1:harvests) {
      producaoVar = 0
      for (v in 1 : length(prodvars)){
        if(v %% 2 != 0){next}
          temp = sum((colheitas[[h]][,v])^2)
          producaoVar =  producaoVar + temp
        }
        colheitas[[h]][,length(prodvars)+1] = producaoVar
    }
  }
  
# Área 4: o peso de produção é inversamente proporcional à soma das variáveis impares
# Prod = 1/(X11+X13) + 1/(...)
  else if (areatype == 4) {
    for(h in 1:harvests) {
       producaoPhase = 0
      for(p in 1:nPhases){
        denominTemp = 0
        for (v in 1 : length(prodvars)){
          if(v %% 2 == 0){next}
          temp = sum(colheitas[[h]][p,v])
          denominTemp =  denominTemp + temp
        }
        temp2 = 1/denominTemp
         producaoPhase =  producaoPhase + temp2
      }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
  
# Área 5: o peso da produção decresce com uma ponderação da soma das variáveis ímpares 
# Prod = 1* X21 + 0,8* X22 + 0,6*X23 + 0,4*X24 + 0,2*X25
  else if (areatype == 5) {
    for(h in 1:harvests) {
      for(p in 1:nPhases){
        producaoVar = 0
        for (v in 1 : length(prodvars)){
          if(v %% 2 == 0){next}
          temp = sum((colheitas[[h]][p,v]))
          producaoVar =  producaoVar + temp
        }
        producaoPhase = 0
        chunk = 100/nPhases
        temp2 = producaoVar*(100-(chunk*p-1))/100
        producaoPhase =  producaoPhase + temp2
      }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
  
# Área 6: o peso da produção cresce com uma ponderação dos valores das variáveis pares:
# Prod = 0,2*X11 + 0,4* X12 + 0,6*X13 + 0,8*X14 + 1*X15
  else if (areatype == 6) {
    for(h in 1:harvests) {
      for(p in 1:nPhases){
        producaoVar = 0
        for (v in 1 : length(prodvars)){
          if(v %% 2 != 0){next}
          temp = sum((colheitas[[h]][p,v]))
          producaoVar =  producaoVar + temp
        }
        producaoPhase = 0
        chunk = 100/nPhases
        temp2 = producaoVar*(100-(chunk*p-1))/100
        producaoPhase =  producaoPhase + temp2
      }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
}#fim else
  
  return(colheitas)
}
```

```{r criaDataFrames}
# A entrada das funções do pacote bnlearn são dataframes, portanto esta função
# cria os dataframes apartir das listas com os dados gerados nas funções abaixo

criaDataFrames <- function (dados){
  fase <- list()
  area <- list()
  for(k in 1:length(dados)){
    for(j in 1:length(dados[[1]][[1]][,1])){
      area_phase <- matrix(0, nrow=length(dados[[1]]),ncol=length(dados[[1]][[1]][1,]))
      for(i in 1:length(dados[[1]])){
        area_phase[i,] <- dados[[1]][[i]][j,]
      }
      fase[[j]] <- data.frame(area_phase)
      colnames(fase[[j]]) <- colnames(dados[[1]][[1]])
      rownames(fase[[j]]) <- rownames(fase[[j]])
      }
    area[[k]] <- fase
    }
  return(area)
}
```

```{r f_minmax}
# faz a normalização dos dados
f_minmax <- function(x){
  minmax = (max(x)-min(x))
  if(minmax==0){
    return(min(x))
  }
  return((x - min(x))/minmax)
}

```

```{r geraGraph}
geraGraph <-function(areaN, file, subtitulo){
  areaN$redes <- rep(c("hc_dag", "hc_dag_raw", "mmhc_dag", "mmhc_dag_raw"),
                     each = 1)
  areaN$periodo <- rep(c("fase 1", "fase 2", "fase 3", "fase 4", "fase 5"), 
                       each = 4)
  areaN$periodo <- factor(area1$periodo, levels = 
                            c("fase 1", "fase 2", "fase 3", "fase 4", "fase 5"))
  png(file, width = 1024, height = 768)
  
  plot(ggplot(areaN, aes(periodo, accuracy, fill = redes)) +
         scale_y_continuous(limits = c(0,100), breaks = seq(0,100,25)) +
         labs(
           title = "Acurácia de Redes Estáticas por fase",
           subtitle = subtitulo,
           caption = "Fonte: Autor(2022)"
  )+
    scale_fill_brewer(palette = "Spectral") + # Spectral; Paired; Set3
    geom_col(position = "dodge", show.legend = TRUE, linetype = 1, alpha = .65) +
    geom_text(aes(label = accuracy), vjust = 1, 
              position = position_dodge(.9),
              size = 3, color = "black")+
    geom_hline(yintercept = mean(areaN$accuracy),
               linetype = "solid", 
               size = .1))

dev.off()
}
```

```{r criaRedes}
### Cria redes pra todas as fases fenológicas da área
criaRedes <- function (areaphase, areatype){

  sample = sample.split(areaphase, SplitRatio = 0.75)
  treino = subset(areaphase, sample == TRUE, )
  rownames(treino)<-NULL
  teste  = subset(areaphase, sample == FALSE)
  rownames(teste)<-NULL
  

  blacklist = data.frame(from = c("X_1","X_1",
                                "X_2", "X_2",
                                "X_3", "X_3",
                                "colheita",  "colheita",  "colheita" ), 
                       to = c("X_2", "X_3", #from v1 
                              "X_1", "X_3", #from v2
                              "X_1", "X_2", #from v3
                              "X_1", "X_2", "X_3")) #from col
  
# constroi whitelist conforme tipo de área
  if(areatype == 1){
      whitelist = data.frame(from = c("X_1", "X_2", "X_3"), 
                            to = c("colheita", "colheita", "colheita"))
    }else if(areatype == 2){
      whitelist = data.frame(from = c("X_1"), 
                            to = c("colheita"))
    }else if(areatype == 3){
      whitelist = data.frame(from = c("X_3"), 
                            to = c("colheita"))
    }else if(areatype == 4){
      whitelist = data.frame(from = c("X_1", "X_3"), 
                            to = c("colheita", "colheita"))
    }else if(areatype == 5){
      whitelist = data.frame(from = c("X_2"), 
                            to = c("colheita"))
    }else if(areatype == 6){
      whitelist = data.frame(from = c("X_1"),
                                        to = c("colheita"))
    }
    
      
      
# hc_dag =      Hill-Climbing COM definicao da topologia da rede
# hc_dag_raw =  Hill-Climbing SEM definicao da topologia da rede
# mmhc_dag =      Max-Min Hill-Climbing COM definicao da topologia da rede
# mmhc_dag_raw =  Max-Min Hill-Climbing SEM definicao da topologia da rede

# Score-based Learning Algorithm
      
      hc_dag <-hc(treino, 
                  whitelist = whitelist,
                  blacklist = blacklist,
                  debug = FALSE)
      plot(hc_dag)

      hc_dag_raw <-hc(treino, debug = FALSE)
      plot(hc_dag_raw)
      
     
# Hybrid Learning Algorithm
      
      mmhc_dag <- mmhc(treino, 
                         whitelist = whitelist,
                         blacklist = blacklist,
                         debug = FALSE)
      plot(mmhc_dag)
      
      mmhc_dag_raw <- mmhc(treino, debug = FALSE)
      plot(mmhc_dag_raw)
      
# treina redes 
      hc_dag_fitted = bn.fit(hc_dag, treino)
      hc_dag_raw_fitted = bn.fit(hc_dag_raw, treino)

      mmhc_dag_fitted = bn.fit(mmhc_dag, treino)
      mmhc_dag_raw_fitted = bn.fit(mmhc_dag_raw, treino)

      
# validacao das redes
      return(validaRede(teste, treino, hc_dag_fitted, hc_dag_raw_fitted, mmhc_dag_fitted, mmhc_dag_raw_fitted))
}
```

```{r validaRede}
validaRede <- function(test, train, dag_fitted1, dag_fitted2, dag_fitted3, dag_fitted4) {
# Define Target variables (Variables to be predicted)
  pred <-'colheita'
# Evidence variables 
#(Variables that you will give information to the BN to do the prediction)
  evid <- names(train)[!names(train) %in% pred]
  
  results1 <- bnMultiVarPrediction(bnFit = dag_fitted1, 
                                  trainSet = train,
                                  testSet = test,
                                  to_predict = pred,
                                  to_evidence = evid, 
                                  calcFunction = 'predict')
  
  results2 <- bnMultiVarPrediction(bnFit = dag_fitted2, 
                                  trainSet = train,
                                  testSet = test,
                                  to_predict = pred,
                                  to_evidence = evid, 
                                  calcFunction = 'predict')
  
  results3 <- bnMultiVarPrediction(bnFit = dag_fitted3, 
                                  trainSet = train,
                                  testSet = test,
                                  to_predict = pred,
                                  to_evidence = evid, 
                                  calcFunction = 'predict')
  
  results4 <- bnMultiVarPrediction(bnFit = dag_fitted4, 
                                  trainSet = train,
                                  testSet = test,
                                  to_predict = pred,
                                  to_evidence = evid, 
                                  calcFunction = 'predict')
# Metrics Evaluation
  
  #print("metricas dag1: ")
  metrics1 <- bnMetricsMultiVarPrediction(reference = test[pred],
                                         prediction = results1$dominantList,
                                         predProbList = results1$probList)
  #print("metricas dag2: ")
  metrics2 <- bnMetricsMultiVarPrediction(reference = test[pred],
                                         prediction = results2$dominantList,
                                         predProbList = results2$probList)
  
  metrics3 <- bnMetricsMultiVarPrediction(reference = test[pred],
                                         prediction = results3$dominantList,
                                         predProbList = results3$probList)
  #print("metricas dag2: ")
  metrics4 <- bnMetricsMultiVarPrediction(reference = test[pred],
                                         prediction = results4$dominantList,
                                         predProbList = results4$probList)
  # print("Matriz de confusão dag 1:")
  # print(metrics1$cmList)
  # print("Matriz de confusão dag 2:")
  # print(metrics2$cmList)
  return(c(metrics1, metrics2, metrics3, metrics4))
}
```

```{r rodaRede}
rodaRede <- function(areadf, areatype){
  area <- list()
  out <- data.frame() 
  nome <- array()
  inome=1
  for(fase in 1:length(areadf)){
    area[[fase]] <- criaRedes(areadf[[fase]], areatype)
    
    out <- bind_rows(out, area[[fase]][3])
    nome[inome] <- paste("fase", fase, "hc_dag")
    inome = inome+1
    
    out <- bind_rows(out, area[[fase]][6])
    nome[inome] <- paste("fase", fase, "hc_dag_raw")
    inome = inome+1
    
    out <- bind_rows(out, area[[fase]][9])
    nome[inome] <- paste("fase", fase, "mmhc_dag")
    inome = inome+1
    
    out <- bind_rows(out, area[[fase]][12])
    nome[inome] <- paste("fase", fase, "mmhc_dag_raw")
    inome = inome+1
  }
  row.names(out$eval)<-nome
  return(out$eval)
}

```

```{r criaRedesDinamc}
criaRedesDinamc <- function(area){
 # area <- list()
 # area <- areas_raw[[1]]

  temp <- area[[length(area)]]
  nvar <- dim(temp)[2]
  size <- length(area)
# CRIA O DF EXPANDIDO COM O N DE CORTES DE TEMPO DESEJADOS PARA A REDE DINÂMICA
  df_fold <- fold_dt(temp, size)
  linhasdf <- dim(df_fold)[1]
  
# PREENCHENDO DF EXPANDIDO COM VALORES DA FASES DA AREA
  inc <- 1
  for(fase in size:1){
    df_fold[,(((nvar*inc)-nvar)+1):(nvar*inc)] <- 
      area[[fase]][1:linhasdf,]
    inc <- inc+1
  }
# ADICIONANDO GRANDE RUIDO NAS COLUNAS COLHEITAS 
# PARA QUE NÃO AFETEM O APRENDIZADO DA REDE

    for(i in 2:(size)){
     df_fold[,nvar*i] <- df_fold[,nvar*i] +
       matrix(rnorm(dim(df_fold)[1], 0, 200), ncol = 1)
    }
  
## SEPARAR EM TREINO E TESTE
  
  spliter <- array(0, dim(df_fold)[1])
  sampleDBN = sample.split(spliter, SplitRatio = 0.75)
  treinoDBN = subset(df_fold, sampleDBN == TRUE, )
  rownames(treinoDBN)<-NULL
  testeDBN  = subset(df_fold, sampleDBN == FALSE)
  rownames(testeDBN)<-NULL
  
# APRENDENDO A DBN
  
   # dag_dbn <- learn_dbn_struc(dt = treinoDBN,
   #                            size = size,
   #                            f_dt = treinoDBN,
   #                            method = "natPsoho")
   
   dag_dbn_2 <- learn_dbn_struc(dt = NULL,
                                size = size,
                                f_dt = treinoDBN,
                                method = "dmmhc",
                                intra = F)
   
# CASO EXISTA, REMOVER ARCOS PARTINDO DOS NÓS 'colheita_t'
   
   # # https://link.springer.com/chapter/10.1007/978-3-030-86271-8_14
   # for(i in 1:(size-1)){
   #    test <-  paste("colheita_t_", i, sep ="")
   #    if(length(which(arcs(dag_dbn)[,"from"] == test)) > 0){
   #      linhas <- which(arcs(dag_dbn)[,"from"] == test)
   #      arcs(dag_dbn) <- arcs(dag_dbn)[-linhas,]
   #    }
   # }
   # 
   #plot(dag_dbn)
   

      for(i in 1:(size-1)){
      test <-  paste("colheita_t_", i, sep ="")
      if(length(which(arcs(dag_dbn_2)[,"from"] == test)) > 0){
        linhas <- which(arcs(dag_dbn_2)[,"from"] == test)
        arcs(dag_dbn_2) <- arcs(dag_dbn_2)[-linhas,]
      }
   }
   
   # plot(dag_dbn_2)
   
   
      
# TREINA A REDE 
   # dag_dbn_fited <- fit_dbn_params(dag_dbn, treinoDBN)
   dag_dbn_fited_2 <- fit_dbn_params(dag_dbn_2, treinoDBN)
    
   # predict_dag_dbn_1 <- forecast_ts(testeDBN, dag_dbn_fited,
   #                                 obj_vars = "colheita_t_0", rep = 1,
   #                                 mode = "approx", ini = 1, len = length(testeDBN), 
   #                                 print_res = T, plot_res = F)
   
   predict_dag_dbn_2_a <- forecast_ts(testeDBN, dag_dbn_fited_2,
                                   obj_vars = "colheita_t_0", rep = 1,
                                   mode = "approx", ini = 1, len = length(testeDBN),
                                   print_res = T, plot_res = F)
   
   predict_dag_dbn_2_e <- forecast_ts(testeDBN, dag_dbn_fited_2,
                                   obj_vars = "colheita_t_0", rep = 1,
                                   mode = "exact", ini = 1, len = length(testeDBN),
                                   print_res = T, plot_res = F)
   
   # return(predict_dag_dbn_1)
   # return(c(predict_dag_dbn_1, predict_dag_dbn_2))
}
```

#### testes
```{r iniciaTeste}
iniciaTeste <- function(){
  file_path = "/home/gui/TCC/R/meu_pacote/teste1.csv"
  nHarvests = 1000
  nphases = 5
  nAreas = 2
  nVars = 3
  #class_names <- c("B", "MB", "M", "MA", "A")
  class_names <- c("B", "M", "A")
# listas para armazenar os dados por área
  areas_list  = list()
  areas_list_disc  = list()
  areas_list  = BuildSimulationData(nHarvests, nphases)
  #areas_list  = BuildSimulationData(nHarvests, nphases, nAreas, 10)
  

#para cada área, cria uma lista de dataframes
#cada dataframe tem os dados de uma fase fenológica
  for(area in 1:length(areas_list)){
    areas_list[area] = criaDataFrames(areas_list[area])
    for(fase in 1:nphases){
      
      model <- preProcess(areas_list[[area]][[fase]], method="range")
     areas_list[[area]][[fase]] <- predict(model, areas_list[[area]][[fase]])
    }
  }
    areas_list_disc = areas_list
  #return(areas_list)

    for(area in 1:length(areas_list)){#para cada área
      for(fase in 1:length(areas_list[[1]])){#para cada fase da área
        areas_list_disc[[area]][[fase]] <- discretize(areas_list[[area]][[fase]],
                                                 #idisc = 'interval',
                                                 ordered = FALSE,
                                                 method = 'hartemink',
                                                 ibreaks = length(class_names)*5,
                                                 breaks = length(class_names))
        for(var in 1:dim(areas_list[[1]][[fase]])[2]){#para cada variável da área/fase
          levels(areas_list_disc[[area]][[fase]][,var]) <- class_names
        }
      }
    }
  return(c(areas_list, areas_list_disc))
}
```


```{r Gera dados}
areas <- iniciaTeste()
areas_raw <- areas[1:(length(areas)/2)]
areas_dis <- areas[((length(areas)/2)+1):length(areas)]
#length(areas_raw[[1]])
# summary(areas_dis[[1]][[1]])
# summary(areas_raw[[6]][[1]])
# areas_dis[[1]][[1]]
```

```{r TESTE - REDES ESTÁTICAS (dblearn)}

area1 <- rodaRede(areas_dis[[1]], 1)
geraGraph(area1, "/home/gui/TCC/R/meu_pacote/saidas/grafico_ESTATICA_A1.png", "Área 2")
write.csv(area1, file = "/home/gui/TCC/R/meu_pacote/saidas/out_area1.csv")

area2 <- rodaRede(areas_dis[[2]], 2)
geraGraph(area2, "/home/gui/TCC/R/meu_pacote/saidas/grafico_ESTATICA_A2.png", "Área 2")
write.csv(area2, file = "/home/gui/TCC/R/meu_pacote/saidas/out_area2.csv")

area3 <- rodaRede(areas_dis[[3]], 3)
geraGraph(area3, "/home/gui/TCC/R/meu_pacote/saidas/grafico_ESTATICA_A3.png", "Área 3")
write.csv(area3, file = "/home/gui/TCC/R/meu_pacote/saidas/out_area3.csv")

area4 <- rodaRede(areas_dis[[4]], 4)
geraGraph(area4, "/home/gui/TCC/R/meu_pacote/saidas/grafico_ESTATICA_A4.png", "Área 4")
write.csv(area4, file = "/home/gui/TCC/R/meu_pacote/saidas/out_area4.csv")

area5 <- rodaRede(areas_dis[[5]], 5)
geraGraph(area5, "/home/gui/TCC/R/meu_pacote/saidas/grafico_ESTATICA_A5.png", "Área 5")
write.csv(area5, file = "/home/gui/TCC/R/meu_pacote/saidas/out_area5.csv")

area6 <- rodaRede(areas_dis[[6]], 6)
geraGraph(area6, "/home/gui/TCC/R/meu_pacote/saidas/grafico_ESTATICA_A6.png", "Área 6")
write.csv(area6, file = "/home/gui/TCC/R/meu_pacote/saidas/out_area6.csv")
```

```{r TESTE - REDES DINAMICAS}

criaRedesDinamc(areas_raw[[1]]) 
#natPsoho
  # The average MAE per execution is: colheita_t_0: 0.2448 # approx
  # The average MAE per execution is: colheita_t_0:  0.259 # exact
#dmmhc:
  # The average MAE per execution is: colheita_t_0: 0.192 # approx
  # The average MAE per execution is: colheita_t_0: 0.195 # exact

criaRedesDinamc(areas_raw[[2]])
#natPsoho
  # The average MAE per execution is: colheita_t_0: 0.195 # approx
  # The average MAE per execution is: colheita_t_0: 0.168 # exact
#dmmhc:
  # The average MAE per execution is: colheita_t_0: 0.297 # approx
  # The average MAE per execution is: colheita_t_0: 0.297 # exact
criaRedesDinamc(areas_raw[[3]]) 
# The average MAE per execution is: colheita_t_0: 0.216 # approx
# The average MAE per execution is: colheita_t_0: 0.278 # exact
criaRedesDinamc(areas_raw[[4]]) 
# The average MAE per execution is: colheita_t_0: 0.0058 # approx
# The average MAE per execution is: colheita_t_0: 0.0111 # exact
criaRedesDinamc(areas_raw[[5]]) 
# The average MAE per execution is: colheita_t_0: 0.106 # approx
# The average MAE per execution is: colheita_t_0: 0.2092 # exact
criaRedesDinamc(areas_raw[[6]]) 
# The average MAE per execution is: colheita_t_0: 0.252 # approx
# The average MAE per execution is: colheita_t_0: 0.2083 # exact

## GERANDO GRÁFICOS:

graficoDBN <- data.frame(Area_1 = c(0.244, 0.259),
                         Area_2 = c(0.195, 0.168),
                         Area_3 = c(0.216, 0.278),
                         Area_4 = c(0.005, 0.0111),
                         Area_5 = c(0.106, 0.209),
                         Area_6 = c(0.252, 0.208),
                         row.names = c("approx", "exact"))

## AFF UMA HORA QUEBRANDO A CABEÇA PRA GERAR ESSE GRÁFICO AQUI 
## E FIZ EM 3 MIN  NO LIBREOFFICE CALC
    #/home/gui/TCC/R/meu_pacote/saidas


    
```

