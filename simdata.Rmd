## Pacote R com as funções de treinamento, execução e visualização de dados

##### importações
```{R}
library(seqHMM)
library(HMM)
library(Hmisc)
```



#### testes
```{r TESTE}

nHarvests = 20
nphases = 3
nAreas = 3
nVars = 3
#BuildSimulationData <- function (nHarvests, nPhases, nAreas = NULL, ...)
# debug(BuildSimulationData)
teste <- BuildSimulationData(nHarvests, nphases, nAreas, nVars)

teste

area_fase <- criaDataFrames(teste)
area_fase[[1]][[1]] # area1-fase1
area_fase[[2]][[1]] # area2-fase1
area_fase[[3]][[1]] # area3-fase1
# e assim por diante


```

```{r}
criaDataFrames <- function (dados){
fase <- list()
area <- list()

for(k in 1:length(teste)){
for(j in 1:length(teste[[1]][[1]][,1])){
  area_phase <- matrix(0, nrow=length(teste[[1]]),ncol=length(teste[[1]][[1]][1,]))
for(i in 1:length(teste[[1]])) {
area_phase[i,] <- teste[[1]][[i]][j,]
}
  fase[[j]] <- data.frame(area_phase)
  colnames(fase[[j]]) <- colnames(teste[[1]][[1]])
  rownames(fase[[j]]) <- rownames(fase[[j]])
}
  area[[k]] <- fase
}
return(area)
}
```

####
#### defVars
```{r}
#Definição das variáveis: nome, valor mínimo, valor máximo, tipo (up=1,osc=2,const=3)

defVars <- function (n_var = NULL, type_var = NULL, name_var = NULL){
  prodVariables = list()
  
  if(is.null(n_var)){
    # type (up=1,osc=2,const=3)
    prodVariables[[1]] = c("PrecAcum",0,1,1)
    prodVariables[[2]] = c("Insol",0,1,2)
    prodVariables[[3]] = c("Compact",-1,1,3)

  return (prodVariables)
  }else
    if(!is.null(type_var) | !is.null(name_var)){
      if(length(type_var)!= n_var | length(name_var)!= n_var){
        stop("parâmetros incorretos. Se informados, tipos e nomes de variáveis devem ser informados para todas as variáveis")
      }else{
        for (i in 1 : n_var){
# type (up=1,osc=2,const=3)
          if(type_var[i] == 3){
            prodVariables[[i]] = c(name_var[i], -1, 1, type_var[i])
          }else{
            prodVariables[[i]] = c(name_var[i], 0, 1, type_var[i])
          }
        }
      }
        return (prodVariables)
        }else{
          for (i in 1 : n_var){
            tempType = sample(1:3, 1)
            tempName <- paste("x", i, sep = "_" )
            if(tempType == 3){
              prodVariables[[i]] = c(tempName, -1, 1, tempType)
              }else{
                prodVariables[[i]] = c(tempName, 0, 1, tempType)
              }
            }
          return (prodVariables)
        }
}

```


#### BuildSimulationData
```{r}
BuildSimulationData <- function (nHarvests, nPhases, nAreas = NULL, ...) {
  areasList <- list()
  #ver aqui um gerados de quantidade de áreas e atribuidor de tipos
  if(is.null(nAreas)){
    areanames = c("Area_1", "Area_2", "Area_3", "Area_4", "Area_5", "Area_6")
    areatype  = c(1,2,3,4,5,6)
    for (i in 1 : length(areanames)){
      areasList[[i]] <- c(areanames =  areanames[i], areatype  = areatype[i])
    }
  }else{
    for (i in 1 : nAreas){
      tempType = sample(1:6, 1)
      #tempType = 5
      tempName <- paste("Area", i, sep = "_")
      areasList[[i]] = c(areaName = tempName,areatype = tempType)
    }
  }
  prodVariables = defVars(...)
  
  #completeSimValues = array(dim=c(length(areanames),nPhases,nHarvests,dim(prodVariables)[2]+1))
  
  completeSimValues = list()
  namesArea = array(dim = length(areasList))
  
  for (a in 1:length(areasList)) {
    cat("Calculando valores da área ",a,"\n")
    completeSimValues[[a]] = setSimVarValues(nHarvests, areasList[[a]][2],prodVariables,nPhases)
    namesArea[a] = paste("Area", a, "type", areasList[[a]][2], sep = "_")
  }
  names(completeSimValues) = namesArea

# NORMALIZAÇÃO DOS VALORES DE COLHEITA
       
temp <- array(dim = nHarvests*nAreas)
i=1
for(a in 1 : nAreas){
    for(h in 1 : nHarvests){
     temp[i] <- completeSimValues[[a]][[h]][1,length(prodVariables)+1]
     i=1+i
    }
}
i=1
temp <- f_minmax(temp)
for(a in 1 : nAreas){
    for(h in 1 : nHarvests){
     completeSimValues[[a]][[h]][,length(prodVariables)+1] <- temp[i]
     i=1+i
    }
  }
  
  return (completeSimValues)
}

```


#### setSimVarValues
```{r}
setSimVarValues <- function (harvests, areatype, prodvars, nPhases) {
  # allHarvestValues = setSimVarValues(nHarvests,areasList[[a]][2],prodVariables,nPhases)
  # [1] "PrecAcum" "0"        "1"        "up" 
 # Definição das variáveis: nome, valor mínimo, valor máximo, tipo (up=1,osc=2,const=3)
  colheitas <-list()
  names_colheitas <- array(dim = harvests)
  
  for(i in 1: harvests){
    fases <- matrix(nrow=nPhases, ncol= length(prodvars)+1)
    colnames(fases) <-  colnames(fases, do.NULL = FALSE, prefix = "variavel_")
    colnames(fases)[length(prodvars)+1] <-  "colheita"
    rownames(fases) <-  rownames(fases, do.NULL = FALSE, prefix = "fase_")
    colheitas[[i]] = fases
     names_colheitas[i] = paste("colheita", i, sep = "_")
  }
       names(colheitas) = names_colheitas
  
  #prodValues = matrix(nrow=harvests,ncol=dim(prodvars)[2]*nPhases+1)
  
  for (j in 1 : length(prodvars)) {
    for (i in 1:harvests) {
      random_value   = runif(1, min=as.numeric(prodvars[[j]][2]), 
                             max=as.numeric(prodvars[[j]][3]))
      last_value_var = 0
      const_value    = random_value
      for (k in 1:nPhases) {
        # type (up=1,osc=2,const=3)
        if (prodvars[[j]][4]==1) {
          v_value = random_value + last_value_var
          last_value_var = v_value
        } else 
        if (prodvars[[j]][4]==2) {
          v_value = random_value 
        } else  
        if (prodvars[[j]][4]==3) {
          v_value = const_value
        }
        
         colheitas[[i]][k,j] = v_value
        
        random_value   = runif(1, min=as.numeric(prodvars[[j]][2]), 
                           max=as.numeric(prodvars[[j]][3]))
      }#for k
    }#for i
  }#for j

# normaliza dos dados das variáves antes de calcular so valores de produção        
for(h in 1 : harvests){
  for(v in 1 : length(prodvars)){
    if(max(colheitas[[h]][,v]) > 1){
      colheitas[[h]][,v] = f_minmax(colheitas[[h]][,v])
    }
  }
}

   # calcula o valor da produção com base nas relações arbitradas com as variáveis 
  
       
##### POR DEFAULT CONSIDERA-SE 3 VARIÁVES:
if(length(prodvars)==3){
       
  ##### Cálculo das áreas: 3 variáveis
  
  #Área 1: o peso de produção varia linearmente com os valores de todas as variáveis 
  #nas duas primeiras fases fenológicas
  #Prod = (X11 + X12 + X21 + X22 + X31 + X32)


  if (areatype == 1) {
    
    for (h in 1: harvests){
      colheitas[[h]][,length(prodvars)+1] = sum(colheitas[[h]][,1:length(prodvars)])
    }
  }
   
  #Área 2: o peso de produção varia com o quadrado de X1
  #Prod = (X11^2 + X12^2 + X13^2 + X14^2 + X15^2)
  else if (areatype == 2) { 
    for(h in 1:harvests) {
        colheitas[[h]][,length(prodvars)+1] = sum((colheitas[[h]][,1])^2)
    }
  }
  #Área 3: o peso de produção varia com o quadrado de X3
  else if (areatype == 3) {
     for(h in 1:harvests) {
        colheitas[[h]][,length(prodvars)+1] = sum((colheitas[[h]][,3])^2)
    }
  }
  #Área 4: o peso de produção é inversamente proporcional à soma de X1 com X3
  #Prod = 1/(X11+X13) + 1/(...)
  else if (areatype == 4) {
    for(h in 1:harvests) {
       producaoPhase = 0
      for(p in 1:nPhases){
        temp = 1/(colheitas[[h]][p,1]+colheitas[[h]][p,3])
         producaoPhase =  producaoPhase + temp
        }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
  #Área 5: o peso da produção decresce com uma ponderação dos valores de X2:
  #Prod = 1* X21 + 0,8* X22 + 0,6*X23 + 0,4*X24 + 0,2*X25
  else if (areatype == 5) {
    for(h in 1:harvests) {
       producaoPhase = 0
      chunk = 100/nPhases
      for(p in 1:nPhases){
        temp = (colheitas[[h]][p,2])*(100-(chunk*p-1))/100
         producaoPhase =  producaoPhase + temp
      }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
  #Área 6: o peso da produção cresce com uma ponderação dos valores de X1:
  #Prod = 0,2*X11 + 0,4* X12 + 0,6*X13 + 0,8*X14 + 1*X15
  else if (areatype == 6) {
    for(h in 1:harvests) {
       producaoPhase = 0
      chunk = 100/nPhases
      for(p in 1:nPhases){
        temp = ((colheitas[[h]][p,1])*(chunk*p))/100
         producaoPhase =  producaoPhase + temp
      }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
}else{
  #SE NÃO TEMOS QUE DEFINIR REGRAS MAIS ALEATÓREAS, PORÉM REGISTRAR AS REGRAS DEFINIDAS
    
  #Área 1: o peso de produção varia linearmente com os valores de todas as variáveis 
  #nas duas primeiras fases fenológicas
  #Prod = (X11 + X12 + X21 + X22 + X31 + X32)


  if (areatype == 1) {
    for (h in 1: harvests){
      colheitas[[h]][,length(prodvars)+1] = sum(colheitas[[h]][,1:length(prodvars)])
    }
  }
  #Área 2: o peso de produção varia com o quadrado das variáveis impares 
  #Prod = Σ(Xi1^2 + Xi2^2 + Xi3^2 + Xi4^2 + Xi5^2) | i=(2k+1), k(0:infinito)
  else if (areatype == 2) { 
    for(h in 1:harvests) {
        producaoVar = 0
        for (v in 1 : length(prodvars)){
          if(v %% 2 == 0){next}
          temp = sum((colheitas[[h]][,v])^2)
          producaoVar =  producaoVar + temp
        }
        colheitas[[h]][,length(prodvars)+1] = producaoVar
    }
  }
  #Área 3: o peso de produção varia com o quadrado das variáveis pares
  #Prod = Σ(Xi1^2 + Xi2^2 + Xi3^2 + Xi4^2 + Xi5^2) | i=(2k), k(0:infinito)
  else if (areatype == 3){
    for(h in 1:harvests) {
      producaoVar = 0
      for (v in 1 : length(prodvars)){
        if(v %% 2 != 0){next}
          temp = sum((colheitas[[h]][,v])^2)
          producaoVar =  producaoVar + temp
        }
        colheitas[[h]][,length(prodvars)+1] = producaoVar
    }
  }
  #Área 4: o peso de produção é inversamente proporcional à soma das variáveis impares
  #Prod = 1/(X11+X13) + 1/(...)
  else if (areatype == 4) {
    for(h in 1:harvests) {
       producaoPhase = 0
      for(p in 1:nPhases){
        denominTemp = 0
        for (v in 1 : length(prodvars)){
          if(v %% 2 == 0){next}
          temp = sum(colheitas[[h]][p,v])
          denominTemp =  denominTemp + temp
        }
        temp2 = 1/denominTemp
         producaoPhase =  producaoPhase + temp2
      }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
  
  #Área 5: o peso da produção decresce com uma ponderação da soma das variáveis ímpares 
  #Prod = 1* X21 + 0,8* X22 + 0,6*X23 + 0,4*X24 + 0,2*X25
  else if (areatype == 5) {
    for(h in 1:harvests) {
      for(p in 1:nPhases){
        producaoVar = 0
        for (v in 1 : length(prodvars)){
          if(v %% 2 == 0){next}
          temp = sum((colheitas[[h]][p,v]))
          producaoVar =  producaoVar + temp
        }
        producaoPhase = 0
        chunk = 100/nPhases
        temp2 = producaoVar*(100-(chunk*p-1))/100
        producaoPhase =  producaoPhase + temp2
      }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
  #Área 6: o peso da produção cresce com uma ponderação dos valores das variáveis pares:
  #Prod = 0,2*X11 + 0,4* X12 + 0,6*X13 + 0,8*X14 + 1*X15
  else if (areatype == 6) {
    for(h in 1:harvests) {
      for(p in 1:nPhases){
        producaoVar = 0
        for (v in 1 : length(prodvars)){
          if(v %% 2 != 0){next}
          temp = sum((colheitas[[h]][p,v]))
          producaoVar =  producaoVar + temp
        }
        producaoPhase = 0
        chunk = 100/nPhases
        temp2 = producaoVar*(100-(chunk*p-1))/100
        producaoPhase =  producaoPhase + temp2
      }
      colheitas[[h]][,length(prodvars)+1] =  producaoPhase
    }
  }
}#fim else
       

  return(colheitas)
}
```

#### f_minmax
```{r}
#gui
#faz a normalização dos dados
f_minmax <- function(x){
  return((x - min(x))/(max(x)-min(x)))
}

```

#### vars_in
```{r}
vars_in <- function (n_var, v_min, v_max, v_names) {
  # desenvolver aqui depois uma função pra organizar os dados de entrada
}
```